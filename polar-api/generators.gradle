buildscript {
	repositories {
		jcenter()
	}
	dependencies {
		classpath 'com.github.javaparser:javaparser-core:3.6.21'
	}
}

import com.github.javaparser.*
import com.github.javaparser.ast.body.*
import static com.github.javaparser.ast.Modifier.*

import java.lang.reflect.Field

def javaFile(qualifiedName, project) {
	def fileName = qualifiedName.replace((char) '.', File.separatorChar) + '.java'
	for (srcDir in project.sourceSets.main.java.srcDirs) {
		def f = new File(srcDir, fileName)  
		if (f.exists()) return f 
	}
	return null
}

def createClass(qualifiedName) {
}

def generateRegistryClassAPIBindings() {
	['leviathan143.polar.common.items.ItemRegistry', 'leviathan143.polar.common.blocks.BlockRegistry'].each {qualifiedName->
		def jFile = javaFile(qualifiedName, rootProject);
		if (jFile == null)
			logger.error "Class ${qualifiedName} not found in ${rootProject}"
		else
		{
			def className = qualifiedName.substring(qualifiedName.lastIndexOf('.') + 1)
			def classDecl = JavaParser.parse(jFile).getClassByName(className).get()
			def bindingClassDecl = new ClassOrInterfaceDeclaration(EnumSet.of(PUBLIC, FINAL), false, "Polar${className}")
			//Add @ObjectHolder annotation
			bindingClassDecl.addSingleMemberAnnotation('ObjectHolder', 'PolarAPI.PROVIDER_MOD_ID')
			//Copy all public static final fields
			for (field in classDecl.fields) {
				if (field.modifiers.containsAll([PUBLIC, STATIC, FINAL])) {
					for (variable in field.variables) {
						bindingClassDecl.addField(variable.type, variable.name as String, PUBLIC, STATIC, FINAL)
					}
				}
			}
			
			def bindingFile = file("src/main/java/leviathan143/polar/api/Polar${className}.java")
			bindingFile.text = bindingClassDecl as String
		}
	}
}

generateRegistryClassAPIBindings()
